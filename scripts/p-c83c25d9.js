function t(t) { return "function" == typeof t } const n = function (t) { const n = t((t => { Error.call(t), t.stack = (new Error).stack })); return n.prototype = Object.create(Error.prototype), n.prototype.constructor = n, n }((t => function (n) { t(this), this.message = n ? `${n.length} errors occurred during unsubscription:\n${n.map(((t, n) => `${n + 1}) ${t.toString()}`)).join("\n  ")}` : "", this.name = "UnsubscriptionError", this.errors = n })); function r(t, n) { if (t) { const r = t.indexOf(n); 0 <= r && t.splice(r, 1) } } class e { constructor(t) { this.initialTeardown = t, this.closed = !1, this._parentage = null, this._finalizers = null } unsubscribe() { let r; if (!this.closed) { this.closed = !0; const { _parentage: e } = this; if (e) if (this._parentage = null, Array.isArray(e)) for (const t of e) t.remove(this); else e.remove(this); const { initialTeardown: i } = this; if (t(i)) try { i() } catch (t) { r = t instanceof n ? t.errors : [t] } const { _finalizers: s } = this; if (s) { this._finalizers = null; for (const t of s) try { o(t) } catch (t) { r = null != r ? r : [], t instanceof n ? r = [...r, ...t.errors] : r.push(t) } } if (r) throw new n(r) } } add(t) { var n; if (t && t !== this) if (this.closed) o(t); else { if (t instanceof e) { if (t.closed || t._hasParent(this)) return; t._addParent(this) } (this._finalizers = null !== (n = this._finalizers) && void 0 !== n ? n : []).push(t) } } _hasParent(t) { const { _parentage: n } = this; return n === t || Array.isArray(n) && n.includes(t) } _addParent(t) { const { _parentage: n } = this; this._parentage = Array.isArray(n) ? (n.push(t), n) : n ? [n, t] : t } _removeParent(t) { const { _parentage: n } = this; n === t ? this._parentage = null : Array.isArray(n) && r(n, t) } remove(t) { const { _finalizers: n } = this; n && r(n, t), t instanceof e && t._removeParent(this) } } function i(n) { return n instanceof e || n && "closed" in n && t(n.remove) && t(n.add) && t(n.unsubscribe) } function o(n) { t(n) ? n() : n.unsubscribe() } e.EMPTY = (() => { const t = new e; return t.closed = !0, t })(); const s = { onUnhandledError: null, onStoppedNotification: null, Promise: void 0, useDeprecatedSynchronousErrorHandling: !1, useDeprecatedNextContext: !1 }, u = { setTimeout(t, n, ...r) { const { delegate: e } = u; return (null == e ? void 0 : e.setTimeout) ? e.setTimeout(t, n, ...r) : setTimeout(t, n, ...r) }, clearTimeout(t) { const { delegate: n } = u; return ((null == n ? void 0 : n.clearTimeout) || clearTimeout)(t) }, delegate: void 0 }; function c(t) { u.setTimeout((() => { const { onUnhandledError: n } = s; if (!n) throw t; n(t) })) } function f() { } const l = a("C", void 0, void 0); function a(t, n, r) { return { kind: t, value: n, error: r } } class h extends e { constructor(t) { super(), this.isStopped = !1, t ? (this.destination = t, i(t) && t.add(this)) : this.destination = w } static create(t, n, r) { return new p(t, n, r) } next(t) { this.isStopped ? m(function (t) { return a("N", t, void 0) }(t), this) : this._next(t) } error(t) { this.isStopped ? m(a("E", void 0, t), this) : (this.isStopped = !0, this._error(t)) } complete() { this.isStopped ? m(l, this) : (this.isStopped = !0, this._complete()) } unsubscribe() { this.closed || (this.isStopped = !0, super.unsubscribe(), this.destination = null) } _next(t) { this.destination.next(t) } _error(t) { try { this.destination.error(t) } finally { this.unsubscribe() } } _complete() { try { this.destination.complete() } finally { this.unsubscribe() } } } const d = Function.prototype.bind; function y(t, n) { return d.call(t, n) } class v { constructor(t) { this.partialObserver = t } next(t) { const { partialObserver: n } = this; if (n.next) try { n.next(t) } catch (t) { b(t) } } error(t) { const { partialObserver: n } = this; if (n.error) try { n.error(t) } catch (t) { b(t) } else b(t) } complete() { const { partialObserver: t } = this; if (t.complete) try { t.complete() } catch (t) { b(t) } } } class p extends h { constructor(n, r, e) { let i; if (super(), t(n) || !n) i = { next: null != n ? n : void 0, error: null != r ? r : void 0, complete: null != e ? e : void 0 }; else { let t; this && s.useDeprecatedNextContext ? (t = Object.create(n), t.unsubscribe = () => this.unsubscribe(), i = { next: n.next && y(n.next, t), error: n.error && y(n.error, t), complete: n.complete && y(n.complete, t) }) : i = n } this.destination = new v(i) } } function b(t) { c(t) } function m(t, n) { const { onStoppedNotification: r } = s; r && u.setTimeout((() => r(t, n))) } const w = { closed: !0, next: f, error: function (t) { throw t }, complete: f }, S = "function" == typeof Symbol && Symbol.observable || "@@observable"; function E(t) { return t } class x { constructor(t) { t && (this._subscribe = t) } lift(t) { const n = new x; return n.source = this, n.operator = t, n } subscribe(n, r, e) { const o = (s = n) && s instanceof h || function (n) { return n && t(n.next) && t(n.error) && t(n.complete) }(s) && i(s) ? n : new p(n, r, e); var s; return (() => { const { operator: t, source: n } = this; o.add(t ? t.call(o, n) : n ? this._subscribe(o) : this._trySubscribe(o)) })(), o } _trySubscribe(t) { try { return this._subscribe(t) } catch (n) { t.error(n) } } forEach(t, n) { return new (n = _(n))(((n, r) => { const e = new p({ next: n => { try { t(n) } catch (t) { r(t), e.unsubscribe() } }, error: r, complete: n }); this.subscribe(e) })) } _subscribe(t) { var n; return null === (n = this.source) || void 0 === n ? void 0 : n.subscribe(t) } [S]() { return this } pipe(...t) { return (0 === (n = t).length ? E : 1 === n.length ? n[0] : function (t) { return n.reduce(((t, n) => n(t)), t) })(this); var n } toPromise(t) { return new (t = _(t))(((t, n) => { let r; this.subscribe((t => r = t), (t => n(t)), (() => t(r))) })) } } function _(t) { var n; return null !== (n = null != t ? t : s.Promise) && void 0 !== n ? n : Promise } function P(n) { return r => { if (function (n) { return t(null == n ? void 0 : n.lift) }(r)) return r.lift((function (t) { try { return n(t, this) } catch (t) { this.error(t) } })); throw new TypeError("Unable to lift unknown Observable type") } } function T(t, n, r, e, i) { return new g(t, n, r, e, i) } x.create = t => new x(t); class g extends h { constructor(t, n, r, e, i, o) { super(t), this.onFinalize = i, this.shouldUnsubscribe = o, this._next = n ? function (r) { try { n(r) } catch (n) { t.error(n) } } : super._next, this._error = e ? function (n) { try { e(n) } catch (n) { t.error(n) } finally { this.unsubscribe() } } : super._error, this._complete = r ? function () { try { r() } catch (n) { t.error(n) } finally { this.unsubscribe() } } : super._complete } unsubscribe() { var t; if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) { const { closed: n } = this; super.unsubscribe(), !n && (null === (t = this.onFinalize) || void 0 === t || t.call(this)) } } } function A(t) { return this instanceof A ? (this.v = t, this) : new A(t) } function O(t) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var n, r = t[Symbol.asyncIterator]; return r ? r.call(t) : (t = function (t) { var n = "function" == typeof Symbol && Symbol.iterator, r = n && t[n], e = 0; if (r) return r.call(t); if (t && "number" == typeof t.length) return { next: function () { return t && e >= t.length && (t = void 0), { value: t && t[e++], done: !t } } }; throw new TypeError(n ? "Object is not iterable." : "Symbol.iterator is not defined.") }(t), n = {}, e("next"), e("throw"), e("return"), n[Symbol.asyncIterator] = function () { return this }, n); function e(r) { n[r] = t[r] && function (n) { return new Promise((function (e, i) { !function (t, n, r, e) { Promise.resolve(e).then((function (n) { t({ value: n, done: r }) }), n) }(e, i, (n = t[r](n)).done, n.value) })) } } } "function" == typeof SuppressedError && SuppressedError; const j = t => t && "number" == typeof t.length && "function" != typeof t, $ = "function" == typeof Symbol && Symbol.iterator ? Symbol.iterator : "@@iterator"; function I(n) { if (n instanceof x) return n; if (null != n) { if (function (n) { return t(n[S]) }(n)) return s = n, new x((n => { const r = s[S](); if (t(r.subscribe)) return r.subscribe(n); throw new TypeError("Provided object does not correctly implement Symbol.observable") })); if (j(n)) return o = n, new x((t => { for (let n = 0; n < o.length && !t.closed; n++)t.next(o[n]); t.complete() })); if (t(null == (i = n) ? void 0 : i.then)) return e = n, new x((t => { e.then((n => { t.closed || (t.next(n), t.complete()) }), (n => t.error(n))).then(null, c) })); if (function (n) { return Symbol.asyncIterator && t(null == n ? void 0 : n[Symbol.asyncIterator]) }(n)) return L(n); if (function (n) { return t(null == n ? void 0 : n[$]) }(n)) return r = n, new x((t => { for (const n of r) if (t.next(n), t.closed) return; t.complete() })); if (function (n) { return t(null == n ? void 0 : n.getReader) }(n)) return L(function (t) { return function (t, n, r) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var e, i = r.apply(t, n || []), o = []; return e = {}, s("next"), s("throw"), s("return"), e[Symbol.asyncIterator] = function () { return this }, e; function s(t) { i[t] && (e[t] = function (n) { return new Promise((function (r, e) { o.push([t, n, r, e]) > 1 || u(t, n) })) }) } function u(t, n) { try { (r = i[t](n)).value instanceof A ? Promise.resolve(r.value.v).then(c, f) : l(o[0][2], r) } catch (t) { l(o[0][3], t) } var r } function c(t) { u("next", t) } function f(t) { u("throw", t) } function l(t, n) { t(n), o.shift(), o.length && u(o[0][0], o[0][1]) } }(this, arguments, (function* () { const n = t.getReader(); try { for (; ;) { const { value: t, done: r } = yield A(n.read()); if (r) return yield A(void 0); yield yield A(t) } } finally { n.releaseLock() } })) }(n)) } var r, e, i, o, s; throw function (t) { return new TypeError(`You provided ${null !== t && "object" == typeof t ? "an invalid object" : `'${t}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`) }(n) } function L(t) { return new x((n => { (function (t, n) { var r, e, i, o, s, u, c, f; return s = this, u = void 0, f = function* () { try { for (r = O(t); !(e = yield r.next()).done;)if (n.next(e.value), n.closed) return } catch (t) { i = { error: t } } finally { try { e && !e.done && (o = r.return) && (yield o.call(r)) } finally { if (i) throw i.error } } n.complete() }, new ((c = void 0) || (c = Promise))((function (t, n) { function r(t) { try { i(f.next(t)) } catch (t) { n(t) } } function e(t) { try { i(f.throw(t)) } catch (t) { n(t) } } function i(n) { var i; n.done ? t(n.value) : (i = n.value, i instanceof c ? i : new c((function (t) { t(i) }))).then(r, e) } i((f = f.apply(s, u || [])).next()) })) })(t, n).catch((t => n.error(t))) })) } function N(t, n) { return P(((r, e) => { let i = 0; r.subscribe(T(e, (r => { e.next(t.call(n, r, i++)) }))) })) } const { isArray: U } = Array; function k(n, r, e = 1 / 0) { return t(r) ? k(((t, e) => N(((n, i) => r(t, n, e, i)))(I(n(t, e)))), e) : ("number" == typeof r && (e = r), P(((t, r) => function (t, n, r, e) { const i = []; let o = 0, s = 0, u = !1; const c = () => { !u || i.length || o || n.complete() }, f = t => o < e ? l(t) : i.push(t), l = t => { o++; let u = !1; I(r(t, s++)).subscribe(T(n, (t => { n.next(t) }), (() => { u = !0 }), void 0, (() => { if (u) try { for (o--; i.length && o < e;) { const t = i.shift(); l(t) } c() } catch (t) { n.error(t) } }))) }; return t.subscribe(T(n, f, (() => { u = !0, c() }))), () => { } }(t, r, n, e)))) } const z = ["addListener", "removeListener"], C = ["addEventListener", "removeEventListener"], D = ["on", "off"]; function Y(n, r, e, i) { if (t(e) && (i = e, e = void 0), i) return Y(n, r, e).pipe((o = i, N((t => function (t, n) { return U(n) ? t(...n) : t(n) }(o, t))))); var o; const [s, u] = function (n) { return t(n.addEventListener) && t(n.removeEventListener) }(n) ? C.map((t => i => n[t](r, i, e))) : function (n) { return t(n.addListener) && t(n.removeListener) }(n) ? z.map(F(n, r)) : function (n) { return t(n.on) && t(n.off) }(n) ? D.map(F(n, r)) : []; if (!s && j(n)) return k((t => Y(t, r, e)))(I(n)); if (!s) throw new TypeError("Invalid event target"); return new x((t => { const n = (...n) => t.next(1 < n.length ? n : n[0]); return s(n), () => u(n) })) } function F(t, n) { return r => e => t[r](n, e) } export { e as S, r as a, T as c, Y as f, P as o }